{"ast":null,"code":"// draw tree class functions start :/\n\nexport class Tree {\n  constructor() {\n    let node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    this.id = 0;\n    this.node = node;\n    this.label = label;\n    this.width = node.length;\n    this.children = children;\n  }\n}\nexport class DrawTree {\n  constructor(tree) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let number = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    this.left = () => {\n      if (this.thread !== undefined) return this.thread;\n      if (this.children.length !== 0) return this.children[0];\n      return undefined;\n      return this.thread || this.children.length && this.children[0];\n    };\n    this.right = () => {\n      if (this.thread) return this.thread;\n      if (this.children.length) return this.children[this.children.length - 1];\n      return undefined;\n      return this.thread || this.children.length && this.children[-1];\n    };\n    this.lbrother = () => {\n      let n = undefined;\n      if (this.parent) {\n        // for(let node in this.parent.children)\n        for (let i = 0; i < this.parent.children.length; i++) {\n          let node = this.parent.children[i];\n          if (node === this) {\n            return n;\n          } else {\n            n = node;\n          }\n        }\n      }\n      return n;\n    };\n    this.get_lmost_sibling = () => {\n      if (!this._lmost_sibling && this.parent && this !== this.parent.children[0]) {\n        this._lmost_sibling = this.parent.children[0];\n      }\n      return this._lmost_sibling;\n    };\n    this.x = -1;\n    this.y = depth;\n    this.tree = tree;\n    this.children = [];\n    for (let i = 0; i < tree.children.length; i++) {\n      let newTree = new DrawTree(tree.children[i], this, depth + 1, i + 1);\n      this.children.push(newTree);\n    }\n    this.parent = parent;\n    this.thread = undefined;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this._lmost_sibling = undefined;\n    this.number = number;\n    // this.lmost_sibling = this.get_lmost_sibling();\n  }\n}\n\nexport function buchheim(tree) {\n  let dt = firstwalk(new DrawTree(tree));\n  let min = second_walk(dt);\n  if (min < 0) {\n    third_walk(dt, -min);\n  }\n  return dt;\n}\nfunction third_walk(tree, n) {\n  tree.x += n;\n  //for (let c in tree.children)\n  for (let i = 0; i < tree.children; i++) {\n    let c = tree.children[i];\n    third_walk(c, n);\n  }\n}\nfunction firstwalk(v) {\n  let distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  //console.log('hue hue hue',v);\n  if (v.children.length === 0) {\n    if (v.get_lmost_sibling()) {\n      v.x = v.lbrother().x + distance;\n    } else {\n      v.x = 0.;\n    }\n  } else {\n    let default_ancestor = v.children[0];\n    //for (let w in v.children)\n    for (let i = 0; i < v.children.length; i++) {\n      let w = v.children[i];\n      firstwalk(w);\n      default_ancestor = apportion(w, default_ancestor, distance);\n    }\n    // console.log(\"finished v =\", v.tree, \"children\");\n    execute_shifts(v);\n    let midpoint = (v.children[0].x + v.children[v.children.length - 1].x) / 2;\n    let ell = v.children[0];\n    let arr = v.children[-1];\n    let w = v.lbrother();\n    if (w) {\n      v.x = w.x + distance;\n      v.mod = v.x - midpoint;\n    } else {\n      v.x = midpoint;\n    }\n  }\n  return v;\n}\nfunction apportion(v, default_ancestor, distance) {\n  let w = v.lbrother();\n  if (w !== undefined) {\n    // inbuchheimnotation:\n    //i == inner;o == outer;r == right;l == left;r = +;l = -\n    let vir, vor, vil, vol, sir, sor, sol, sil;\n    vir = vor = v;\n    vil = w;\n    vol = v.get_lmost_sibling();\n    sir = sor = v.mod;\n    sil = vil.mod;\n    sol = vol.mod;\n    while (vil.right() && vir.left()) {\n      vil = vil.right();\n      vir = vir.left();\n      vol = vol.left();\n      vor = vor.right();\n      vor.ancestor = v;\n      let shift = vil.x + sil - (vir.x + sir) + distance;\n      if (shift > 0) {\n        move_subtree(ancestor(vil, v, default_ancestor), v, shift);\n        sir = sir + shift;\n        sor = sor + shift;\n      }\n      sil += vil.mod;\n      sir += vir.mod;\n      sol += vol.mod;\n      sor += vor.mod;\n    }\n    if (vil.right() && !vor.right()) {\n      vor.thread = vil.right();\n      vor.mod += sil - sor;\n    } else {\n      if (vir.left() && !vol.left()) {\n        vol.thread = vir.left();\n        vol.mod += sir - sol;\n      }\n      default_ancestor = v;\n    }\n  }\n  return default_ancestor;\n}\nfunction move_subtree(wl, wr, shift) {\n  let subtrees = wr.number - wl.number;\n  // console.log(wl.tree, \"is conflicted with\", wr.tree, 'moving', subtrees, 'shift', shift);\n  // print wl, wr, wr.number, wl.number, shift, subtrees, shift / subtrees\n  wr.change -= shift / subtrees;\n  wr.shift += shift;\n  wl.change += shift / subtrees;\n  wr.x += shift;\n  wr.mod += shift;\n}\nfunction execute_shifts(v) {\n  let shift, change;\n  shift = change = 0;\n  // for (let w in v.children[:: - 1])\n  for (let i = v.children.length - 1; i >= 0; i--) {\n    let w = v.children[i];\n    //console.log(\"shift:\", w.tree.node, shift, w.change);\n    w.x += shift;\n    w.mod += shift;\n    change += w.change;\n    shift += w.shift + change;\n  }\n}\nfunction ancestor(vil, v, default_ancestor) {\n  if (vil.ancestor in v.parent.children) {\n    return vil.ancestor;\n  } else return default_ancestor;\n}\nfunction second_walk(v) {\n  let m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let min = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n  v.x += m;\n  v.y = depth;\n  if (min === undefined || v.x < min) min = v.x;\n\n  // for (let w in v.children)\n  for (let i = 0; i < v.children.length; i++) {\n    let w = v.children[i];\n    min = second_walk(w, m + v.mod, depth + 1, min);\n  }\n  return min;\n}\nfunction dfs(tree) {\n  if (tree.tree.node === 'B') return;\n  console.log(tree.tree.node, tree.x, tree.y);\n  for (let i = 0; i < tree.children.length; i++) dfs(tree.children[i]);\n}\n/*\r\nlet blank = new Tree('B',[]);\r\nlet ll = new Tree(\"ll\",[]);\r\nlet lr = new Tree(\"lr\",[]);\r\nlet rr = new Tree(\"rr\",[]);\r\nlet rl = new Tree(\"rl\",[]);\r\nlet l = new Tree(\"l\",[ll,lr]);\r\nlet r = new Tree(\"r\",[rl,rr]);\r\nlet root = new Tree(\"root\",[l,r] );\r\n\r\nlet tree = buchheim(root);\r\nconsole.log(\"==================================================================\");\r\ndfs(tree);\r\n*/","map":{"version":3,"names":["Tree","constructor","node","arguments","length","undefined","children","label","id","width","DrawTree","tree","parent","depth","number","left","thread","right","lbrother","n","i","get_lmost_sibling","_lmost_sibling","x","y","newTree","push","mod","ancestor","change","shift","buchheim","dt","firstwalk","min","second_walk","third_walk","c","v","distance","default_ancestor","w","apportion","execute_shifts","midpoint","ell","arr","vir","vor","vil","vol","sir","sor","sol","sil","move_subtree","wl","wr","subtrees","m","dfs","console","log"],"sources":["C:/Users/Admin/Desktop/visualizer1/AlgorithmVisualizer/src/Graph/Tree.js"],"sourcesContent":["// draw tree class functions start :/\r\n\r\n\r\nexport class Tree{\r\n    constructor(node=0,children=[],label=\"\") {\r\n        this.id = 0;\r\n        this.node = node;\r\n        this.label = label;\r\n        this.width = node.length;\r\n        this.children = children;\r\n    }\r\n}\r\n\r\nexport class DrawTree{\r\n    constructor(tree,parent=undefined,depth=0,number=1) {\r\n        this.x =-1;\r\n        this.y = depth;\r\n        this.tree = tree;\r\n        this.children = [];\r\n        for( let i=0;i<tree.children.length;i++ ){\r\n            let newTree = new DrawTree(tree.children[i],this,depth+1,i+1);\r\n            this.children.push(newTree);\r\n        }\r\n        this.parent = parent;\r\n        this.thread = undefined;\r\n        this.mod = 0;\r\n        this.ancestor = this;\r\n        this.change = 0;\r\n        this.shift = 0;\r\n        this._lmost_sibling = undefined;\r\n        this.number = number;\r\n        // this.lmost_sibling = this.get_lmost_sibling();\r\n    }\r\n\r\n    left = ()=>{\r\n        if( this.thread!==undefined ) return this.thread;\r\n        if( this.children.length!==0 ) return this.children[0];\r\n        return undefined;\r\n        return this.thread || this.children.length && this.children[0];\r\n    }\r\n    right = ()=>{\r\n        if( this.thread ) return this.thread;\r\n        if( this.children.length ) return this.children[this.children.length-1];\r\n        return undefined;\r\n        return this.thread || this.children.length && this.children[-1];\r\n    }\r\n    lbrother = ()=>{\r\n        let n = undefined;\r\n        if( this.parent ){\r\n            // for(let node in this.parent.children)\r\n            for(let i=0;i<this.parent.children.length;i++)\r\n            {\r\n                let node = this.parent.children[i];\r\n                if( node === this ){\r\n                    return n;\r\n                }else{\r\n                    n = node;\r\n                }\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n    get_lmost_sibling = ()=>{\r\n        if( !this._lmost_sibling && this.parent && this!==this.parent.children[0] ){\r\n            this._lmost_sibling = this.parent.children[0];\r\n        }\r\n        return this._lmost_sibling;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nexport function buchheim(tree) {\r\n    let dt = firstwalk(new DrawTree(tree))\r\n    let min = second_walk(dt)\r\n    if (min < 0) {\r\n        third_walk(dt, -min);\r\n    }\r\n    return dt\r\n}\r\n\r\nfunction third_walk(tree, n) {\r\n    tree.x += n;\r\n    //for (let c in tree.children)\r\n    for(let i=0;i<tree.children;i++)\r\n    {\r\n        let c = tree.children[i];\r\n        third_walk(c, n);\r\n    }\r\n}\r\n\r\nfunction firstwalk(v, distance = 1) {\r\n    //console.log('hue hue hue',v);\r\n    if (v.children.length === 0) {\r\n        if (v.get_lmost_sibling()) {\r\n            v.x = v.lbrother().x + distance;\r\n        } else {\r\n            v.x = 0.;\r\n        }\r\n    } else {\r\n        let default_ancestor = v.children[0];\r\n        //for (let w in v.children)\r\n        for(let i=0;i<v.children.length;i++) {\r\n            let w = v.children[i];\r\n            firstwalk(w);\r\n            default_ancestor = apportion(w, default_ancestor, distance);\r\n        }\r\n        // console.log(\"finished v =\", v.tree, \"children\");\r\n        execute_shifts(v);\r\n\r\n        let midpoint = (v.children[0].x + v.children[v.children.length-1].x) / 2;\r\n\r\n        let ell = v.children[0];\r\n        let arr = v.children[-1];\r\n        let w = v.lbrother();\r\n        if (w) {\r\n            v.x = w.x + distance;\r\n            v.mod = v.x - midpoint;\r\n        } else {\r\n            v.x = midpoint;\r\n        }\r\n    }\r\n    return v;\r\n}\r\n\r\n\r\nfunction apportion(v, default_ancestor, distance) {\r\n\r\n    let w = v.lbrother();\r\n    if (w !== undefined) {\r\n        // inbuchheimnotation:\r\n        //i == inner;o == outer;r == right;l == left;r = +;l = -\r\n        let vir, vor, vil, vol, sir, sor, sol, sil;\r\n        vir = vor = v;\r\n        vil = w;\r\n        vol = v.get_lmost_sibling();\r\n        sir = sor = v.mod;\r\n        sil = vil.mod;\r\n        sol = vol.mod;\r\n        while (vil.right() && vir.left()) {\r\n            vil = vil.right();\r\n            vir = vir.left();\r\n            vol = vol.left();\r\n            vor = vor.right();\r\n            vor.ancestor = v;\r\n            let shift = (vil.x + sil) - (vir.x + sir) + distance;\r\n            if (shift > 0) {\r\n                move_subtree(ancestor(vil, v, default_ancestor), v, shift);\r\n                sir = sir + shift;\r\n                sor = sor + shift;\r\n            }\r\n            sil += vil.mod;\r\n            sir += vir.mod;\r\n            sol += vol.mod;\r\n            sor += vor.mod;\r\n        }\r\n        if (vil.right() && !vor.right()) {\r\n            vor.thread = vil.right();\r\n            vor.mod += sil - sor;\r\n        } else {\r\n            if (vir.left() && !vol.left()) {\r\n                vol.thread = vir.left();\r\n                vol.mod += sir - sol;\r\n            }\r\n            default_ancestor = v\r\n        }\r\n    }\r\n    return default_ancestor\r\n}\r\n\r\nfunction move_subtree(wl, wr, shift) {\r\n    let subtrees = wr.number - wl.number;\r\n    // console.log(wl.tree, \"is conflicted with\", wr.tree, 'moving', subtrees, 'shift', shift);\r\n    // print wl, wr, wr.number, wl.number, shift, subtrees, shift / subtrees\r\n    wr.change -= shift / subtrees;\r\n    wr.shift += shift;\r\n    wl.change += shift / subtrees;\r\n    wr.x += shift;\r\n    wr.mod += shift;\r\n}\r\n\r\nfunction execute_shifts(v) {\r\n    let shift, change;\r\n    shift = change = 0;\r\n    // for (let w in v.children[:: - 1])\r\n    for(let i=v.children.length-1;i>=0;i--){\r\n        let w = v.children[i];\r\n        //console.log(\"shift:\", w.tree.node, shift, w.change);\r\n        w.x += shift;\r\n        w.mod += shift;\r\n        change += w.change;\r\n        shift += w.shift + change;\r\n    }\r\n}\r\n\r\nfunction ancestor(vil, v, default_ancestor) {\r\n\r\n    if (vil.ancestor in v.parent.children){\r\n\r\n        return vil.ancestor;\r\n    }\r\n    else\r\n        return default_ancestor;\r\n}\r\n\r\nfunction second_walk(v, m = 0, depth = 0, min = undefined) {\r\n    v.x += m;\r\n    v.y = depth;\r\n\r\n    if (min === undefined || v.x < min)\r\n        min = v.x;\r\n\r\n    // for (let w in v.children)\r\n    for(let i=0;i<v.children.length;i++){\r\n        let w = v.children[i];\r\n        min = second_walk(w, m + v.mod, depth + 1, min);\r\n    }\r\n    return min;\r\n}\r\n\r\nfunction dfs(tree){\r\n    if( tree.tree.node === 'B' ) return;\r\n    console.log( tree.tree.node, tree.x,tree.y );\r\n    for(let i=0;i<tree.children.length;i++)\r\n        dfs(tree.children[i]);\r\n}\r\n/*\r\nlet blank = new Tree('B',[]);\r\nlet ll = new Tree(\"ll\",[]);\r\nlet lr = new Tree(\"lr\",[]);\r\nlet rr = new Tree(\"rr\",[]);\r\nlet rl = new Tree(\"rl\",[]);\r\nlet l = new Tree(\"l\",[ll,lr]);\r\nlet r = new Tree(\"r\",[rl,rr]);\r\nlet root = new Tree(\"root\",[l,r] );\r\n\r\nlet tree = buchheim(root);\r\nconsole.log(\"==================================================================\");\r\ndfs(tree);\r\n*/\r\n"],"mappings":"AAAA;;AAGA,OAAO,MAAMA,IAAI;EACbC,WAAWA,CAAA,EAA8B;IAAA,IAA7BC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAC,CAAC;IAAA,IAACG,QAAQ,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAC,EAAE;IAAA,IAACI,KAAK,GAAAJ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAC,EAAE;IACnC,IAAI,CAACK,EAAE,GAAG,CAAC;IACX,IAAI,CAACN,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACK,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACE,KAAK,GAAGP,IAAI,CAACE,MAAM;IACxB,IAAI,CAACE,QAAQ,GAAGA,QAAQ;EAC5B;AACJ;AAEA,OAAO,MAAMI,QAAQ;EACjBT,WAAWA,CAACU,IAAI,EAAoC;IAAA,IAAnCC,MAAM,GAAAT,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAACE,SAAS;IAAA,IAACQ,KAAK,GAAAV,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAC,CAAC;IAAA,IAACW,MAAM,GAAAX,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAC,CAAC;IAAA,KAoBlDY,IAAI,GAAG,MAAI;MACP,IAAI,IAAI,CAACC,MAAM,KAAGX,SAAS,EAAG,OAAO,IAAI,CAACW,MAAM;MAChD,IAAI,IAAI,CAACV,QAAQ,CAACF,MAAM,KAAG,CAAC,EAAG,OAAO,IAAI,CAACE,QAAQ,CAAC,CAAC,CAAC;MACtD,OAAOD,SAAS;MAChB,OAAO,IAAI,CAACW,MAAM,IAAI,IAAI,CAACV,QAAQ,CAACF,MAAM,IAAI,IAAI,CAACE,QAAQ,CAAC,CAAC,CAAC;IAClE,CAAC;IAAA,KACDW,KAAK,GAAG,MAAI;MACR,IAAI,IAAI,CAACD,MAAM,EAAG,OAAO,IAAI,CAACA,MAAM;MACpC,IAAI,IAAI,CAACV,QAAQ,CAACF,MAAM,EAAG,OAAO,IAAI,CAACE,QAAQ,CAAC,IAAI,CAACA,QAAQ,CAACF,MAAM,GAAC,CAAC,CAAC;MACvE,OAAOC,SAAS;MAChB,OAAO,IAAI,CAACW,MAAM,IAAI,IAAI,CAACV,QAAQ,CAACF,MAAM,IAAI,IAAI,CAACE,QAAQ,CAAC,CAAC,CAAC,CAAC;IACnE,CAAC;IAAA,KACDY,QAAQ,GAAG,MAAI;MACX,IAAIC,CAAC,GAAGd,SAAS;MACjB,IAAI,IAAI,CAACO,MAAM,EAAE;QACb;QACA,KAAI,IAAIQ,CAAC,GAAC,CAAC,EAACA,CAAC,GAAC,IAAI,CAACR,MAAM,CAACN,QAAQ,CAACF,MAAM,EAACgB,CAAC,EAAE,EAC7C;UACI,IAAIlB,IAAI,GAAG,IAAI,CAACU,MAAM,CAACN,QAAQ,CAACc,CAAC,CAAC;UAClC,IAAIlB,IAAI,KAAK,IAAI,EAAE;YACf,OAAOiB,CAAC;UACZ,CAAC,MAAI;YACDA,CAAC,GAAGjB,IAAI;UACZ;QACJ;MACJ;MACA,OAAOiB,CAAC;IACZ,CAAC;IAAA,KACDE,iBAAiB,GAAG,MAAI;MACpB,IAAI,CAAC,IAAI,CAACC,cAAc,IAAI,IAAI,CAACV,MAAM,IAAI,IAAI,KAAG,IAAI,CAACA,MAAM,CAACN,QAAQ,CAAC,CAAC,CAAC,EAAE;QACvE,IAAI,CAACgB,cAAc,GAAG,IAAI,CAACV,MAAM,CAACN,QAAQ,CAAC,CAAC,CAAC;MACjD;MACA,OAAO,IAAI,CAACgB,cAAc;IAC9B,CAAC;IApDG,IAAI,CAACC,CAAC,GAAE,CAAC,CAAC;IACV,IAAI,CAACC,CAAC,GAAGX,KAAK;IACd,IAAI,CAACF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACL,QAAQ,GAAG,EAAE;IAClB,KAAK,IAAIc,CAAC,GAAC,CAAC,EAACA,CAAC,GAACT,IAAI,CAACL,QAAQ,CAACF,MAAM,EAACgB,CAAC,EAAE,EAAE;MACrC,IAAIK,OAAO,GAAG,IAAIf,QAAQ,CAACC,IAAI,CAACL,QAAQ,CAACc,CAAC,CAAC,EAAC,IAAI,EAACP,KAAK,GAAC,CAAC,EAACO,CAAC,GAAC,CAAC,CAAC;MAC7D,IAAI,CAACd,QAAQ,CAACoB,IAAI,CAACD,OAAO,CAAC;IAC/B;IACA,IAAI,CAACb,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACI,MAAM,GAAGX,SAAS;IACvB,IAAI,CAACsB,GAAG,GAAG,CAAC;IACZ,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,KAAK,GAAG,CAAC;IACd,IAAI,CAACR,cAAc,GAAGjB,SAAS;IAC/B,IAAI,CAACS,MAAM,GAAGA,MAAM;IACpB;EACJ;AAsCJ;;AAKA,OAAO,SAASiB,QAAQA,CAACpB,IAAI,EAAE;EAC3B,IAAIqB,EAAE,GAAGC,SAAS,CAAC,IAAIvB,QAAQ,CAACC,IAAI,CAAC,CAAC;EACtC,IAAIuB,GAAG,GAAGC,WAAW,CAACH,EAAE,CAAC;EACzB,IAAIE,GAAG,GAAG,CAAC,EAAE;IACTE,UAAU,CAACJ,EAAE,EAAE,CAACE,GAAG,CAAC;EACxB;EACA,OAAOF,EAAE;AACb;AAEA,SAASI,UAAUA,CAACzB,IAAI,EAAEQ,CAAC,EAAE;EACzBR,IAAI,CAACY,CAAC,IAAIJ,CAAC;EACX;EACA,KAAI,IAAIC,CAAC,GAAC,CAAC,EAACA,CAAC,GAACT,IAAI,CAACL,QAAQ,EAACc,CAAC,EAAE,EAC/B;IACI,IAAIiB,CAAC,GAAG1B,IAAI,CAACL,QAAQ,CAACc,CAAC,CAAC;IACxBgB,UAAU,CAACC,CAAC,EAAElB,CAAC,CAAC;EACpB;AACJ;AAEA,SAASc,SAASA,CAACK,CAAC,EAAgB;EAAA,IAAdC,QAAQ,GAAApC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAC9B;EACA,IAAImC,CAAC,CAAChC,QAAQ,CAACF,MAAM,KAAK,CAAC,EAAE;IACzB,IAAIkC,CAAC,CAACjB,iBAAiB,CAAC,CAAC,EAAE;MACvBiB,CAAC,CAACf,CAAC,GAAGe,CAAC,CAACpB,QAAQ,CAAC,CAAC,CAACK,CAAC,GAAGgB,QAAQ;IACnC,CAAC,MAAM;MACHD,CAAC,CAACf,CAAC,GAAG,EAAE;IACZ;EACJ,CAAC,MAAM;IACH,IAAIiB,gBAAgB,GAAGF,CAAC,CAAChC,QAAQ,CAAC,CAAC,CAAC;IACpC;IACA,KAAI,IAAIc,CAAC,GAAC,CAAC,EAACA,CAAC,GAACkB,CAAC,CAAChC,QAAQ,CAACF,MAAM,EAACgB,CAAC,EAAE,EAAE;MACjC,IAAIqB,CAAC,GAAGH,CAAC,CAAChC,QAAQ,CAACc,CAAC,CAAC;MACrBa,SAAS,CAACQ,CAAC,CAAC;MACZD,gBAAgB,GAAGE,SAAS,CAACD,CAAC,EAAED,gBAAgB,EAAED,QAAQ,CAAC;IAC/D;IACA;IACAI,cAAc,CAACL,CAAC,CAAC;IAEjB,IAAIM,QAAQ,GAAG,CAACN,CAAC,CAAChC,QAAQ,CAAC,CAAC,CAAC,CAACiB,CAAC,GAAGe,CAAC,CAAChC,QAAQ,CAACgC,CAAC,CAAChC,QAAQ,CAACF,MAAM,GAAC,CAAC,CAAC,CAACmB,CAAC,IAAI,CAAC;IAExE,IAAIsB,GAAG,GAAGP,CAAC,CAAChC,QAAQ,CAAC,CAAC,CAAC;IACvB,IAAIwC,GAAG,GAAGR,CAAC,CAAChC,QAAQ,CAAC,CAAC,CAAC,CAAC;IACxB,IAAImC,CAAC,GAAGH,CAAC,CAACpB,QAAQ,CAAC,CAAC;IACpB,IAAIuB,CAAC,EAAE;MACHH,CAAC,CAACf,CAAC,GAAGkB,CAAC,CAAClB,CAAC,GAAGgB,QAAQ;MACpBD,CAAC,CAACX,GAAG,GAAGW,CAAC,CAACf,CAAC,GAAGqB,QAAQ;IAC1B,CAAC,MAAM;MACHN,CAAC,CAACf,CAAC,GAAGqB,QAAQ;IAClB;EACJ;EACA,OAAON,CAAC;AACZ;AAGA,SAASI,SAASA,CAACJ,CAAC,EAAEE,gBAAgB,EAAED,QAAQ,EAAE;EAE9C,IAAIE,CAAC,GAAGH,CAAC,CAACpB,QAAQ,CAAC,CAAC;EACpB,IAAIuB,CAAC,KAAKpC,SAAS,EAAE;IACjB;IACA;IACA,IAAI0C,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG;IAC1CP,GAAG,GAAGC,GAAG,GAAGV,CAAC;IACbW,GAAG,GAAGR,CAAC;IACPS,GAAG,GAAGZ,CAAC,CAACjB,iBAAiB,CAAC,CAAC;IAC3B8B,GAAG,GAAGC,GAAG,GAAGd,CAAC,CAACX,GAAG;IACjB2B,GAAG,GAAGL,GAAG,CAACtB,GAAG;IACb0B,GAAG,GAAGH,GAAG,CAACvB,GAAG;IACb,OAAOsB,GAAG,CAAChC,KAAK,CAAC,CAAC,IAAI8B,GAAG,CAAChC,IAAI,CAAC,CAAC,EAAE;MAC9BkC,GAAG,GAAGA,GAAG,CAAChC,KAAK,CAAC,CAAC;MACjB8B,GAAG,GAAGA,GAAG,CAAChC,IAAI,CAAC,CAAC;MAChBmC,GAAG,GAAGA,GAAG,CAACnC,IAAI,CAAC,CAAC;MAChBiC,GAAG,GAAGA,GAAG,CAAC/B,KAAK,CAAC,CAAC;MACjB+B,GAAG,CAACpB,QAAQ,GAAGU,CAAC;MAChB,IAAIR,KAAK,GAAImB,GAAG,CAAC1B,CAAC,GAAG+B,GAAG,IAAKP,GAAG,CAACxB,CAAC,GAAG4B,GAAG,CAAC,GAAGZ,QAAQ;MACpD,IAAIT,KAAK,GAAG,CAAC,EAAE;QACXyB,YAAY,CAAC3B,QAAQ,CAACqB,GAAG,EAAEX,CAAC,EAAEE,gBAAgB,CAAC,EAAEF,CAAC,EAAER,KAAK,CAAC;QAC1DqB,GAAG,GAAGA,GAAG,GAAGrB,KAAK;QACjBsB,GAAG,GAAGA,GAAG,GAAGtB,KAAK;MACrB;MACAwB,GAAG,IAAIL,GAAG,CAACtB,GAAG;MACdwB,GAAG,IAAIJ,GAAG,CAACpB,GAAG;MACd0B,GAAG,IAAIH,GAAG,CAACvB,GAAG;MACdyB,GAAG,IAAIJ,GAAG,CAACrB,GAAG;IAClB;IACA,IAAIsB,GAAG,CAAChC,KAAK,CAAC,CAAC,IAAI,CAAC+B,GAAG,CAAC/B,KAAK,CAAC,CAAC,EAAE;MAC7B+B,GAAG,CAAChC,MAAM,GAAGiC,GAAG,CAAChC,KAAK,CAAC,CAAC;MACxB+B,GAAG,CAACrB,GAAG,IAAI2B,GAAG,GAAGF,GAAG;IACxB,CAAC,MAAM;MACH,IAAIL,GAAG,CAAChC,IAAI,CAAC,CAAC,IAAI,CAACmC,GAAG,CAACnC,IAAI,CAAC,CAAC,EAAE;QAC3BmC,GAAG,CAAClC,MAAM,GAAG+B,GAAG,CAAChC,IAAI,CAAC,CAAC;QACvBmC,GAAG,CAACvB,GAAG,IAAIwB,GAAG,GAAGE,GAAG;MACxB;MACAb,gBAAgB,GAAGF,CAAC;IACxB;EACJ;EACA,OAAOE,gBAAgB;AAC3B;AAEA,SAASe,YAAYA,CAACC,EAAE,EAAEC,EAAE,EAAE3B,KAAK,EAAE;EACjC,IAAI4B,QAAQ,GAAGD,EAAE,CAAC3C,MAAM,GAAG0C,EAAE,CAAC1C,MAAM;EACpC;EACA;EACA2C,EAAE,CAAC5B,MAAM,IAAIC,KAAK,GAAG4B,QAAQ;EAC7BD,EAAE,CAAC3B,KAAK,IAAIA,KAAK;EACjB0B,EAAE,CAAC3B,MAAM,IAAIC,KAAK,GAAG4B,QAAQ;EAC7BD,EAAE,CAAClC,CAAC,IAAIO,KAAK;EACb2B,EAAE,CAAC9B,GAAG,IAAIG,KAAK;AACnB;AAEA,SAASa,cAAcA,CAACL,CAAC,EAAE;EACvB,IAAIR,KAAK,EAAED,MAAM;EACjBC,KAAK,GAAGD,MAAM,GAAG,CAAC;EAClB;EACA,KAAI,IAAIT,CAAC,GAACkB,CAAC,CAAChC,QAAQ,CAACF,MAAM,GAAC,CAAC,EAACgB,CAAC,IAAE,CAAC,EAACA,CAAC,EAAE,EAAC;IACnC,IAAIqB,CAAC,GAAGH,CAAC,CAAChC,QAAQ,CAACc,CAAC,CAAC;IACrB;IACAqB,CAAC,CAAClB,CAAC,IAAIO,KAAK;IACZW,CAAC,CAACd,GAAG,IAAIG,KAAK;IACdD,MAAM,IAAIY,CAAC,CAACZ,MAAM;IAClBC,KAAK,IAAIW,CAAC,CAACX,KAAK,GAAGD,MAAM;EAC7B;AACJ;AAEA,SAASD,QAAQA,CAACqB,GAAG,EAAEX,CAAC,EAAEE,gBAAgB,EAAE;EAExC,IAAIS,GAAG,CAACrB,QAAQ,IAAIU,CAAC,CAAC1B,MAAM,CAACN,QAAQ,EAAC;IAElC,OAAO2C,GAAG,CAACrB,QAAQ;EACvB,CAAC,MAEG,OAAOY,gBAAgB;AAC/B;AAEA,SAASL,WAAWA,CAACG,CAAC,EAAqC;EAAA,IAAnCqB,CAAC,GAAAxD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAAA,IAAEU,KAAK,GAAAV,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAAA,IAAE+B,GAAG,GAAA/B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGE,SAAS;EACrDiC,CAAC,CAACf,CAAC,IAAIoC,CAAC;EACRrB,CAAC,CAACd,CAAC,GAAGX,KAAK;EAEX,IAAIqB,GAAG,KAAK7B,SAAS,IAAIiC,CAAC,CAACf,CAAC,GAAGW,GAAG,EAC9BA,GAAG,GAAGI,CAAC,CAACf,CAAC;;EAEb;EACA,KAAI,IAAIH,CAAC,GAAC,CAAC,EAACA,CAAC,GAACkB,CAAC,CAAChC,QAAQ,CAACF,MAAM,EAACgB,CAAC,EAAE,EAAC;IAChC,IAAIqB,CAAC,GAAGH,CAAC,CAAChC,QAAQ,CAACc,CAAC,CAAC;IACrBc,GAAG,GAAGC,WAAW,CAACM,CAAC,EAAEkB,CAAC,GAAGrB,CAAC,CAACX,GAAG,EAAEd,KAAK,GAAG,CAAC,EAAEqB,GAAG,CAAC;EACnD;EACA,OAAOA,GAAG;AACd;AAEA,SAAS0B,GAAGA,CAACjD,IAAI,EAAC;EACd,IAAIA,IAAI,CAACA,IAAI,CAACT,IAAI,KAAK,GAAG,EAAG;EAC7B2D,OAAO,CAACC,GAAG,CAAEnD,IAAI,CAACA,IAAI,CAACT,IAAI,EAAES,IAAI,CAACY,CAAC,EAACZ,IAAI,CAACa,CAAE,CAAC;EAC5C,KAAI,IAAIJ,CAAC,GAAC,CAAC,EAACA,CAAC,GAACT,IAAI,CAACL,QAAQ,CAACF,MAAM,EAACgB,CAAC,EAAE,EAClCwC,GAAG,CAACjD,IAAI,CAACL,QAAQ,CAACc,CAAC,CAAC,CAAC;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}