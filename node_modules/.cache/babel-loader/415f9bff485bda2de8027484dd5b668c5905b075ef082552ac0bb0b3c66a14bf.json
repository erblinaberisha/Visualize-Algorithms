{"ast":null,"code":"// draw tree class functions start :/\n\nexport class Tree {\n  constructor(node = 0, children = [], label = \"\") {\n    this.id = 0;\n    this.node = node;\n    this.label = label;\n    this.width = node.length;\n    this.children = children;\n  }\n}\nexport class DrawTree {\n  constructor(tree, parent = undefined, depth = 0, number = 1) {\n    this.left = () => {\n      if (this.thread !== undefined) return this.thread;\n      if (this.children.length !== 0) return this.children[0];\n      return undefined;\n      return this.thread || this.children.length && this.children[0];\n    };\n    this.right = () => {\n      if (this.thread) return this.thread;\n      if (this.children.length) return this.children[this.children.length - 1];\n      return undefined;\n      return this.thread || this.children.length && this.children[-1];\n    };\n    this.lbrother = () => {\n      let n = undefined;\n      if (this.parent) {\n        // for(let node in this.parent.children)\n        for (let i = 0; i < this.parent.children.length; i++) {\n          let node = this.parent.children[i];\n          if (node === this) {\n            return n;\n          } else {\n            n = node;\n          }\n        }\n      }\n      return n;\n    };\n    this.get_lmost_sibling = () => {\n      if (!this._lmost_sibling && this.parent && this !== this.parent.children[0]) {\n        this._lmost_sibling = this.parent.children[0];\n      }\n      return this._lmost_sibling;\n    };\n    this.x = -1;\n    this.y = depth;\n    this.tree = tree;\n    this.children = [];\n    for (let i = 0; i < tree.children.length; i++) {\n      let newTree = new DrawTree(tree.children[i], this, depth + 1, i + 1);\n      this.children.push(newTree);\n    }\n    this.parent = parent;\n    this.thread = undefined;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this._lmost_sibling = undefined;\n    this.number = number;\n    // this.lmost_sibling = this.get_lmost_sibling();\n  }\n}\n\nexport function buchheim(tree) {\n  let dt = firstwalk(new DrawTree(tree));\n  let min = second_walk(dt);\n  if (min < 0) {\n    third_walk(dt, -min);\n  }\n  return dt;\n}\nfunction third_walk(tree, n) {\n  tree.x += n;\n  //for (let c in tree.children)\n  for (let i = 0; i < tree.children; i++) {\n    let c = tree.children[i];\n    third_walk(c, n);\n  }\n}\nfunction firstwalk(v, distance = 1) {\n  //console.log('hue hue hue',v);\n  if (v.children.length === 0) {\n    if (v.get_lmost_sibling()) {\n      v.x = v.lbrother().x + distance;\n    } else {\n      v.x = 0.;\n    }\n  } else {\n    let default_ancestor = v.children[0];\n    //for (let w in v.children)\n    for (let i = 0; i < v.children.length; i++) {\n      let w = v.children[i];\n      firstwalk(w);\n      default_ancestor = apportion(w, default_ancestor, distance);\n    }\n    // console.log(\"finished v =\", v.tree, \"children\");\n    execute_shifts(v);\n    let midpoint = (v.children[0].x + v.children[v.children.length - 1].x) / 2;\n    let ell = v.children[0];\n    let arr = v.children[-1];\n    let w = v.lbrother();\n    if (w) {\n      v.x = w.x + distance;\n      v.mod = v.x - midpoint;\n    } else {\n      v.x = midpoint;\n    }\n  }\n  return v;\n}\nfunction apportion(v, default_ancestor, distance) {\n  let w = v.lbrother();\n  if (w !== undefined) {\n    // inbuchheimnotation:\n    //i == inner;o == outer;r == right;l == left;r = +;l = -\n    let vir, vor, vil, vol, sir, sor, sol, sil;\n    vir = vor = v;\n    vil = w;\n    vol = v.get_lmost_sibling();\n    sir = sor = v.mod;\n    sil = vil.mod;\n    sol = vol.mod;\n    while (vil.right() && vir.left()) {\n      vil = vil.right();\n      vir = vir.left();\n      vol = vol.left();\n      vor = vor.right();\n      vor.ancestor = v;\n      let shift = vil.x + sil - (vir.x + sir) + distance;\n      if (shift > 0) {\n        move_subtree(ancestor(vil, v, default_ancestor), v, shift);\n        sir = sir + shift;\n        sor = sor + shift;\n      }\n      sil += vil.mod;\n      sir += vir.mod;\n      sol += vol.mod;\n      sor += vor.mod;\n    }\n    if (vil.right() && !vor.right()) {\n      vor.thread = vil.right();\n      vor.mod += sil - sor;\n    } else {\n      if (vir.left() && !vol.left()) {\n        vol.thread = vir.left();\n        vol.mod += sir - sol;\n      }\n      default_ancestor = v;\n    }\n  }\n  return default_ancestor;\n}\nfunction move_subtree(wl, wr, shift) {\n  let subtrees = wr.number - wl.number;\n  // console.log(wl.tree, \"is conflicted with\", wr.tree, 'moving', subtrees, 'shift', shift);\n  // print wl, wr, wr.number, wl.number, shift, subtrees, shift / subtrees\n  wr.change -= shift / subtrees;\n  wr.shift += shift;\n  wl.change += shift / subtrees;\n  wr.x += shift;\n  wr.mod += shift;\n}\nfunction execute_shifts(v) {\n  let shift, change;\n  shift = change = 0;\n  // for (let w in v.children[:: - 1])\n  for (let i = v.children.length - 1; i >= 0; i--) {\n    let w = v.children[i];\n    //console.log(\"shift:\", w.tree.node, shift, w.change);\n    w.x += shift;\n    w.mod += shift;\n    change += w.change;\n    shift += w.shift + change;\n  }\n}\nfunction ancestor(vil, v, default_ancestor) {\n  if (vil.ancestor in v.parent.children) {\n    return vil.ancestor;\n  } else return default_ancestor;\n}\nfunction second_walk(v, m = 0, depth = 0, min = undefined) {\n  v.x += m;\n  v.y = depth;\n  if (min === undefined || v.x < min) min = v.x;\n\n  // for (let w in v.children)\n  for (let i = 0; i < v.children.length; i++) {\n    let w = v.children[i];\n    min = second_walk(w, m + v.mod, depth + 1, min);\n  }\n  return min;\n}\nfunction dfs(tree) {\n  if (tree.tree.node === 'B') return;\n  console.log(tree.tree.node, tree.x, tree.y);\n  for (let i = 0; i < tree.children.length; i++) dfs(tree.children[i]);\n}\n/*\nlet blank = new Tree('B',[]);\nlet ll = new Tree(\"ll\",[]);\nlet lr = new Tree(\"lr\",[]);\nlet rr = new Tree(\"rr\",[]);\nlet rl = new Tree(\"rl\",[]);\nlet l = new Tree(\"l\",[ll,lr]);\nlet r = new Tree(\"r\",[rl,rr]);\nlet root = new Tree(\"root\",[l,r] );\n\nlet tree = buchheim(root);\nconsole.log(\"==================================================================\");\ndfs(tree);\n*/","map":{"version":3,"names":["Tree","constructor","node","children","label","id","width","length","DrawTree","tree","parent","undefined","depth","number","left","thread","right","lbrother","n","i","get_lmost_sibling","_lmost_sibling","x","y","newTree","push","mod","ancestor","change","shift","buchheim","dt","firstwalk","min","second_walk","third_walk","c","v","distance","default_ancestor","w","apportion","execute_shifts","midpoint","ell","arr","vir","vor","vil","vol","sir","sor","sol","sil","move_subtree","wl","wr","subtrees","m","dfs","console","log"],"sources":["C:/Users/Admin/Desktop/AlgorithmVisualizer-master/src/Graph/Tree.js"],"sourcesContent":["// draw tree class functions start :/\n\n\nexport class Tree{\n    constructor(node=0,children=[],label=\"\") {\n        this.id = 0;\n        this.node = node;\n        this.label = label;\n        this.width = node.length;\n        this.children = children;\n    }\n}\n\nexport class DrawTree{\n    constructor(tree,parent=undefined,depth=0,number=1) {\n        this.x =-1;\n        this.y = depth;\n        this.tree = tree;\n        this.children = [];\n        for( let i=0;i<tree.children.length;i++ ){\n            let newTree = new DrawTree(tree.children[i],this,depth+1,i+1);\n            this.children.push(newTree);\n        }\n        this.parent = parent;\n        this.thread = undefined;\n        this.mod = 0;\n        this.ancestor = this;\n        this.change = 0;\n        this.shift = 0;\n        this._lmost_sibling = undefined;\n        this.number = number;\n        // this.lmost_sibling = this.get_lmost_sibling();\n    }\n\n    left = ()=>{\n        if( this.thread!==undefined ) return this.thread;\n        if( this.children.length!==0 ) return this.children[0];\n        return undefined;\n        return this.thread || this.children.length && this.children[0];\n    }\n    right = ()=>{\n        if( this.thread ) return this.thread;\n        if( this.children.length ) return this.children[this.children.length-1];\n        return undefined;\n        return this.thread || this.children.length && this.children[-1];\n    }\n    lbrother = ()=>{\n        let n = undefined;\n        if( this.parent ){\n            // for(let node in this.parent.children)\n            for(let i=0;i<this.parent.children.length;i++)\n            {\n                let node = this.parent.children[i];\n                if( node === this ){\n                    return n;\n                }else{\n                    n = node;\n                }\n            }\n        }\n        return n;\n    }\n    get_lmost_sibling = ()=>{\n        if( !this._lmost_sibling && this.parent && this!==this.parent.children[0] ){\n            this._lmost_sibling = this.parent.children[0];\n        }\n        return this._lmost_sibling;\n    }\n\n\n}\n\n\n\n\nexport function buchheim(tree) {\n    let dt = firstwalk(new DrawTree(tree))\n    let min = second_walk(dt)\n    if (min < 0) {\n        third_walk(dt, -min);\n    }\n    return dt\n}\n\nfunction third_walk(tree, n) {\n    tree.x += n;\n    //for (let c in tree.children)\n    for(let i=0;i<tree.children;i++)\n    {\n        let c = tree.children[i];\n        third_walk(c, n);\n    }\n}\n\nfunction firstwalk(v, distance = 1) {\n    //console.log('hue hue hue',v);\n    if (v.children.length === 0) {\n        if (v.get_lmost_sibling()) {\n            v.x = v.lbrother().x + distance;\n        } else {\n            v.x = 0.;\n        }\n    } else {\n        let default_ancestor = v.children[0];\n        //for (let w in v.children)\n        for(let i=0;i<v.children.length;i++) {\n            let w = v.children[i];\n            firstwalk(w);\n            default_ancestor = apportion(w, default_ancestor, distance);\n        }\n        // console.log(\"finished v =\", v.tree, \"children\");\n        execute_shifts(v);\n\n        let midpoint = (v.children[0].x + v.children[v.children.length-1].x) / 2;\n\n        let ell = v.children[0];\n        let arr = v.children[-1];\n        let w = v.lbrother();\n        if (w) {\n            v.x = w.x + distance;\n            v.mod = v.x - midpoint;\n        } else {\n            v.x = midpoint;\n        }\n    }\n    return v;\n}\n\n\nfunction apportion(v, default_ancestor, distance) {\n\n    let w = v.lbrother();\n    if (w !== undefined) {\n        // inbuchheimnotation:\n        //i == inner;o == outer;r == right;l == left;r = +;l = -\n        let vir, vor, vil, vol, sir, sor, sol, sil;\n        vir = vor = v;\n        vil = w;\n        vol = v.get_lmost_sibling();\n        sir = sor = v.mod;\n        sil = vil.mod;\n        sol = vol.mod;\n        while (vil.right() && vir.left()) {\n            vil = vil.right();\n            vir = vir.left();\n            vol = vol.left();\n            vor = vor.right();\n            vor.ancestor = v;\n            let shift = (vil.x + sil) - (vir.x + sir) + distance;\n            if (shift > 0) {\n                move_subtree(ancestor(vil, v, default_ancestor), v, shift);\n                sir = sir + shift;\n                sor = sor + shift;\n            }\n            sil += vil.mod;\n            sir += vir.mod;\n            sol += vol.mod;\n            sor += vor.mod;\n        }\n        if (vil.right() && !vor.right()) {\n            vor.thread = vil.right();\n            vor.mod += sil - sor;\n        } else {\n            if (vir.left() && !vol.left()) {\n                vol.thread = vir.left();\n                vol.mod += sir - sol;\n            }\n            default_ancestor = v\n        }\n    }\n    return default_ancestor\n}\n\nfunction move_subtree(wl, wr, shift) {\n    let subtrees = wr.number - wl.number;\n    // console.log(wl.tree, \"is conflicted with\", wr.tree, 'moving', subtrees, 'shift', shift);\n    // print wl, wr, wr.number, wl.number, shift, subtrees, shift / subtrees\n    wr.change -= shift / subtrees;\n    wr.shift += shift;\n    wl.change += shift / subtrees;\n    wr.x += shift;\n    wr.mod += shift;\n}\n\nfunction execute_shifts(v) {\n    let shift, change;\n    shift = change = 0;\n    // for (let w in v.children[:: - 1])\n    for(let i=v.children.length-1;i>=0;i--){\n        let w = v.children[i];\n        //console.log(\"shift:\", w.tree.node, shift, w.change);\n        w.x += shift;\n        w.mod += shift;\n        change += w.change;\n        shift += w.shift + change;\n    }\n}\n\nfunction ancestor(vil, v, default_ancestor) {\n\n    if (vil.ancestor in v.parent.children){\n\n        return vil.ancestor;\n    }\n    else\n        return default_ancestor;\n}\n\nfunction second_walk(v, m = 0, depth = 0, min = undefined) {\n    v.x += m;\n    v.y = depth;\n\n    if (min === undefined || v.x < min)\n        min = v.x;\n\n    // for (let w in v.children)\n    for(let i=0;i<v.children.length;i++){\n        let w = v.children[i];\n        min = second_walk(w, m + v.mod, depth + 1, min);\n    }\n    return min;\n}\n\nfunction dfs(tree){\n    if( tree.tree.node === 'B' ) return;\n    console.log( tree.tree.node, tree.x,tree.y );\n    for(let i=0;i<tree.children.length;i++)\n        dfs(tree.children[i]);\n}\n/*\nlet blank = new Tree('B',[]);\nlet ll = new Tree(\"ll\",[]);\nlet lr = new Tree(\"lr\",[]);\nlet rr = new Tree(\"rr\",[]);\nlet rl = new Tree(\"rl\",[]);\nlet l = new Tree(\"l\",[ll,lr]);\nlet r = new Tree(\"r\",[rl,rr]);\nlet root = new Tree(\"root\",[l,r] );\n\nlet tree = buchheim(root);\nconsole.log(\"==================================================================\");\ndfs(tree);\n*/\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}