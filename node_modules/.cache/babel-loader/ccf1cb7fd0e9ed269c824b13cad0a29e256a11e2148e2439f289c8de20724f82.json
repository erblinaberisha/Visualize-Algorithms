{"ast":null,"code":"export function selectionSort(arr) {\n  const pairs = [];\n  let n = arr.length;\n  const prevRect = arr.slice();\n  // One by one move boundary of unsorted subarray\n  for (let i = 0; i < n - 1; i++) {\n    let min_idx = i;\n    for (let j = i + 1; j < n; j++) {\n      pairs.push({\n        xx: min_idx,\n        yy: j,\n        changed: false\n      });\n      if (prevRect[j].width < prevRect[min_idx].width) {\n        min_idx = j;\n      }\n    }\n\n    // Swap the found minimum element with the first\n    // element\n    const recti = {\n      ...prevRect[i]\n    };\n    const rectj = {\n      ...prevRect[min_idx]\n    };\n    prevRect[min_idx] = recti;\n    prevRect[i] = rectj;\n    pairs.push({\n      xx: min_idx,\n      yy: i,\n      changed: true\n    });\n    pairs.push({\n      xx: i,\n      yy: i,\n      changed: false\n    });\n  }\n  pairs.push({\n    xx: n - 1,\n    yy: n - 1,\n    changed: false\n  });\n  return pairs;\n}\nexport function bubbleSort(arr) {\n  const pairs = [];\n  let n = arr.length;\n  const prevRect = arr.slice();\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = 0; j < n - i - 1; j++) {\n      if (prevRect[j].width > prevRect[j + 1].width) {\n        // swap arr[j+1] and arr[j]\n        const recti = {\n          ...prevRect[j]\n        };\n        const rectj = {\n          ...prevRect[j + 1]\n        };\n        prevRect[j + 1] = recti;\n        prevRect[j] = rectj;\n        pairs.push({\n          xx: j,\n          yy: j + 1,\n          changed: true\n        });\n      } else {\n        pairs.push({\n          xx: j,\n          yy: j + 1,\n          changed: false\n        });\n      }\n      if (j === n - i - 2) {\n        pairs.push({\n          xx: n - i - 1,\n          yy: n - i - 1,\n          changed: false\n        });\n      }\n    }\n  }\n  pairs.push({\n    xx: 0,\n    yy: 0,\n    changed: false\n  });\n  return pairs;\n}\nexport function insertionSort(arr) {\n  const pairs = [];\n  let n = arr.length;\n  const prevRect = arr.slice();\n  for (let i = 1; i < n; ++i) {\n    let key = prevRect[i].width;\n    let j = i - 1;\n    while (j >= 0 && prevRect[j].width > key) {\n      const recti = {\n        ...prevRect[j]\n      };\n      const rectj = {\n        ...prevRect[j + 1]\n      };\n      prevRect[j + 1] = recti;\n      prevRect[j] = rectj;\n      pairs.push({\n        xx: j,\n        yy: j + 1,\n        changed: true\n      });\n      j = j - 1;\n    }\n    // arr[j + 1] = arr[i];\n  }\n\n  for (let i = 0; i < n; i++) {\n    pairs.push({\n      xx: i,\n      yy: i,\n      changed: true\n    });\n  }\n  return pairs;\n}","map":{"version":3,"names":["selectionSort","arr","pairs","n","length","prevRect","slice","i","min_idx","j","push","xx","yy","changed","width","recti","rectj","bubbleSort","insertionSort","key"],"sources":["C:/Users/Admin/Desktop/AlgorithmVisualizer-master/src/algorithms/sortingAlgorithms.js"],"sourcesContent":["export function selectionSort(arr) {\n    const pairs = [];\n    let n = arr.length;\n    const prevRect = arr.slice();\n    // One by one move boundary of unsorted subarray\n    for (let i = 0; i < n-1; i++)\n    {\n        let min_idx = i;\n        for (let j = i+1; j < n; j++){\n            pairs.push( {\n                xx:min_idx,\n                yy:j,\n                changed:false\n            } );\n            if (prevRect[j].width < prevRect[min_idx].width){\n                min_idx = j;\n            }\n        }\n\n        // Swap the found minimum element with the first\n        // element\n        const recti = {...prevRect[i]};\n        const rectj = {...prevRect[min_idx]};\n        prevRect[min_idx] = recti;\n        prevRect[i] = rectj;\n        pairs.push( {\n            xx:min_idx,\n            yy:i,\n            changed:true\n        } );\n        pairs.push( {\n            xx:i,\n            yy:i,\n            changed:false\n        });\n    }\n    pairs.push({\n            xx:n-1,\n            yy:n-1,\n            changed:false\n        }\n    )\n    return pairs;\n}\n\nexport function bubbleSort(arr){\n    const pairs= [];\n    let n = arr.length;\n    const prevRect = arr.slice();\n    for (let i = 0; i < n-1; i++){\n        for (let j = 0; j < n-i-1; j++){\n            if (prevRect[j].width > prevRect[j+1].width) {\n                // swap arr[j+1] and arr[j]\n                const recti = {...prevRect[j]};\n                const rectj = {...prevRect[j+1]};\n                prevRect[j+1] = recti;\n                prevRect[j] = rectj;\n                pairs.push( {\n                    xx:j,\n                    yy:j+1,\n                    changed:true\n                } );\n            } else{\n                pairs.push( {\n                    xx:j,\n                    yy:j+1,\n                    changed:false\n                } );\n            }\n            if( j === n-i-2 ){\n                pairs.push( {\n                    xx:n-i-1,\n                    yy:n-i-1,\n                    changed:false\n                } );\n            }\n        }\n    }\n    pairs.push({\n            xx:0,\n            yy:0,\n            changed:false\n        }\n    )\n    return pairs;\n}\n\nexport function insertionSort(arr){\n    const pairs = [];\n    let n = arr.length;\n    const prevRect = arr.slice();\n    for (let i = 1; i < n; ++i) {\n        let key = prevRect[i].width;\n        let j = i - 1;\n\n        while (j >= 0 && prevRect[j].width > key) {\n            const recti = {...prevRect[j]};\n            const rectj = {...prevRect[j+1]};\n            prevRect[j+1] = recti;\n            prevRect[j] = rectj;\n            pairs.push( {\n                xx:j,\n                yy:j+1,\n                changed:true\n            } );\n            j = j - 1;\n        }\n       // arr[j + 1] = arr[i];\n    }\n    for(let i=0;i<n;i++){\n        pairs.push({\n            xx:i,\n            yy:i,\n            changed:true\n        })\n    }\n    return pairs;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}