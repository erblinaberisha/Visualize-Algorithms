{"ast":null,"code":"export function getMaze(board, row, col) {\n  const pairs = [];\n  let newBoard = board.slice();\n  for (let i = 0; i < col; i++) {\n    newBoard[0][i].isWall = true;\n    pairs.push({\n      xx: 0,\n      yy: i\n    });\n  }\n  for (let i = 0; i < row; i++) {\n    newBoard[i][col - 1].isWall = true;\n    pairs.push({\n      xx: i,\n      yy: col - 1\n    });\n  }\n  for (let i = col - 1; i >= 0; i--) {\n    newBoard[row - 1][i].isWall = true;\n    pairs.push({\n      xx: row - 1,\n      yy: i\n    });\n  }\n  for (let i = row - 1; i >= 0; i--) {\n    newBoard[i][0].isWall = true;\n    pairs.push({\n      xx: i,\n      yy: 0\n    });\n  }\n  decideMaze(pairs, newBoard, 1, row - 2, 1, col - 2);\n  //console.log(\"here\");\n  return pairs;\n}\nlet val = 0;\nfunction decideMaze(pairs, board, startRow, endRow, startCol, endCol) {\n  //console.log(\"count\");\n  val++;\n  if (endRow - startRow <= 1 && endCol - startCol <= 1) {\n    return;\n  }\n  if (endCol - startCol > endRow - startRow) {\n    recursiveMazeVertical(pairs, board, startRow, endRow, startCol, endCol);\n  } else {\n    recursiveMazeHorizontal(pairs, board, startRow, endRow, startCol, endCol);\n  }\n}\nfunction recursiveMazeVertical(pairs, board, startRow, endRow, startCol, endCol) {\n  let mid = Math.floor((endCol + startCol) / 2);\n  let random = Math.floor(Math.random() * (endRow - startRow + 1)) + startRow;\n  //console.log( \"row \",random,\" \",startRow,\" \",endRow );\n  let start = startRow;\n  if (!board[startRow - 1][mid].isWall) {\n    random = start;\n    start++;\n  }\n  let end = endRow;\n  if (!board[endRow + 1][mid].isWall) {\n    random = end;\n    end--;\n  }\n  for (let i = start; i <= end; i++) {\n    if (i !== random) {\n      board[i][mid].isWall = true;\n      pairs.push({\n        xx: i,\n        yy: mid\n      });\n    }\n  }\n  decideMaze(pairs, board, startRow, endRow, startCol, mid - 1);\n  decideMaze(pairs, board, startRow, endRow, mid + 1, endCol);\n}\nfunction recursiveMazeHorizontal(pairs, board, startRow, endRow, startCol, endCol) {\n  let mid = Math.floor((endRow + startRow) / 2);\n  //  console.log(\"mid: \",mid);\n  let random = Math.floor(Math.random() * (endCol - startCol + 1)) + startCol;\n  let start = startCol;\n  if (!board[mid][startCol - 1].isWall) {\n    random = start;\n    start++;\n  }\n  let end = endCol;\n  if (!board[mid][endCol + 1].isWall) {\n    random = end;\n    end--;\n  }\n  for (let i = start; i <= end; i++) {\n    if (i !== random) {\n      board[mid][i].isWall = true;\n      pairs.push({\n        xx: mid,\n        yy: i\n      });\n    }\n  }\n  decideMaze(pairs, board, startRow, mid - 1, startCol, endCol);\n  decideMaze(pairs, board, mid + 1, endRow, startCol, endCol);\n}","map":{"version":3,"names":["getMaze","board","row","col","pairs","newBoard","slice","i","isWall","push","xx","yy","decideMaze","val","startRow","endRow","startCol","endCol","recursiveMazeVertical","recursiveMazeHorizontal","mid","Math","floor","random","start","end"],"sources":["C:/Users/Admin/Desktop/visualizer1/AlgorithmVisualizer/src/algorithms/recursiveMaze.js"],"sourcesContent":["export function getMaze(board,row,col){\r\n    const pairs = [];\r\n    let newBoard = board.slice();\r\n    for( let i = 0;i <col;i++){\r\n        newBoard[0][i].isWall = true;\r\n        pairs.push({\r\n            xx:0,\r\n            yy:i\r\n        });\r\n    }\r\n    for( let i = 0;i <row;i++){\r\n        newBoard[i][col-1].isWall = true;\r\n        pairs.push({\r\n            xx:i,\r\n            yy:col-1\r\n        });\r\n    }\r\n    for( let i = col-1;i>=0;i-- ){\r\n        newBoard[row-1][i].isWall = true;\r\n        pairs.push({\r\n            xx:row-1,\r\n            yy:i\r\n        });\r\n    }\r\n    for(let i = row-1;i>=0;i--){\r\n        newBoard[i][0].isWall = true;\r\n        pairs.push({\r\n            xx:i,\r\n            yy:0\r\n        });\r\n    }\r\n    decideMaze(pairs,newBoard,1,row-2,1,col-2);\r\n    //console.log(\"here\");\r\n    return pairs;\r\n}\r\nlet val = 0;\r\n\r\nfunction decideMaze(pairs,board,startRow,endRow,startCol,endCol) {\r\n    //console.log(\"count\");\r\n    val++;\r\n\r\n    if( ((endRow-startRow) <=1) && ((endCol - startCol) <=1) ){\r\n        return;\r\n    }\r\n\r\n     if( (endCol - startCol) > (endRow - startRow) ){\r\n        recursiveMazeVertical(pairs,board,startRow,endRow,startCol,endCol);\r\n    } else{\r\n        recursiveMazeHorizontal(pairs,board,startRow,endRow,startCol,endCol);\r\n    }\r\n}\r\nfunction recursiveMazeVertical(pairs,board,startRow,endRow,startCol,endCol){\r\n    let mid = Math.floor((endCol+startCol)/2);\r\n    let random = Math.floor(Math.random() * (endRow-startRow+1)) + startRow;\r\n    //console.log( \"row \",random,\" \",startRow,\" \",endRow );\r\n    let start = startRow;\r\n    if( !board[startRow-1][mid].isWall ){\r\n        random = start;\r\n        start++;\r\n    }\r\n    let end = endRow;\r\n    if( !board[endRow+1][mid].isWall ){\r\n        random = end;\r\n        end--;\r\n    }\r\n    for(let i = start;i<=end;i++){\r\n        if( i!==random ){\r\n            board[i][mid].isWall = true;\r\n            pairs.push({\r\n                xx:i,\r\n                yy:mid\r\n            });\r\n        }\r\n    }\r\n    decideMaze(pairs,board,startRow,endRow,startCol,mid-1);\r\n    decideMaze(pairs,board,startRow,endRow,mid+1,endCol);\r\n}\r\nfunction recursiveMazeHorizontal(pairs,board,startRow,endRow,startCol,endCol){\r\n    let mid = Math.floor((endRow+startRow)/2);\r\n  //  console.log(\"mid: \",mid);\r\n    let random = Math.floor(Math.random() * (endCol-startCol+1)) + startCol;\r\n    let start = startCol;\r\n    if( !board[mid][startCol-1].isWall ){\r\n        random = start;\r\n        start++;\r\n    }\r\n    let end = endCol;\r\n    if( !board[mid][endCol+1].isWall ){\r\n        random = end;\r\n        end--;\r\n    }\r\n    for(let i = start;i<=end;i++){\r\n        if( i!==random ){\r\n            board[mid][i].isWall = true;\r\n            pairs.push({\r\n                xx:mid,\r\n                yy:i\r\n            });\r\n        }\r\n    }\r\n    decideMaze(pairs,board,startRow,mid-1,startCol,endCol);\r\n    decideMaze(pairs,board,mid+1,endRow,startCol,endCol);\r\n\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}